# How to parse code to AST in clang?

​	clang::ParseAST - Parse the entire file specified, notifying the ASTConsumer as the file is parsed. This inserts the parsed decls into the translation unit held by Ctx.

```c++
 99 void clang::ParseAST(Preprocessor &PP, ASTConsumer *Consumer,
100                      ASTContext &Ctx, bool PrintStats,
101                      TranslationUnitKind TUKind,
102                      CodeCompleteConsumer *CompletionConsumer,
103                      bool SkipFunctionBodies) {
104 
105   std::unique_ptr<Sema> S(
106       new Sema(PP, Ctx, *Consumer, TUKind, CompletionConsumer));
107 
108   // Recover resources if we crash before exiting this method.
109   llvm::CrashRecoveryContextCleanupRegistrar<Sema> CleanupSema(S.get());
110 
111   ParseAST(*S.get(), PrintStats, SkipFunctionBodies);
112 }
113 
114 void clang::ParseAST(Sema &S, bool PrintStats, bool SkipFunctionBodies) {
115   // Collect global stats on Decls/Stmts (until we have a module streamer).
116   if (PrintStats) {
117     Decl::EnableStatistics();
118     Stmt::EnableStatistics();
119   }
120 
121   // Also turn on collection of stats inside of the Sema object.
122   bool OldCollectStats = PrintStats;
123   std::swap(OldCollectStats, S.CollectStats);
124 
125   // Initialize the template instantiation observer chain.
126   // FIXME: See note on "finalize" below.
127   initialize(S.TemplateInstCallbacks, S);
128 
129   ASTConsumer *Consumer = &S.getASTConsumer();
130 
131   std::unique_ptr<Parser> ParseOP(
132       new Parser(S.getPreprocessor(), S, SkipFunctionBodies));
133   Parser &P = *ParseOP.get();
134 
135   llvm::CrashRecoveryContextCleanupRegistrar<const void, ResetStackCleanup>
136       CleanupPrettyStack(llvm::SavePrettyStackState());
137   PrettyStackTraceParserEntry CrashInfo(P);
138 
139   // Recover resources if we crash before exiting this method.
140   llvm::CrashRecoveryContextCleanupRegistrar<Parser>
141     CleanupParser(ParseOP.get());
142 
143   S.getPreprocessor().EnterMainSourceFile();
144   ExternalASTSource *External = S.getASTContext().getExternalSource();
145   if (External)
146     External->StartTranslationUnit(Consumer);
147 
148   // If a PCH through header is specified that does not have an include in
149   // the source, or a PCH is being created with #pragma hdrstop with nothing
150   // after the pragma, there won't be any tokens or a Lexer.
151   bool HaveLexer = S.getPreprocessor().getCurrentLexer();
152 
153   if (HaveLexer) {
154     llvm::TimeTraceScope TimeScope("Frontend", StringRef(""));
155     P.Initialize();
156     Parser::DeclGroupPtrTy ADecl;
157     for (bool AtEOF = P.ParseFirstTopLevelDecl(ADecl); !AtEOF;
158          AtEOF = P.ParseTopLevelDecl(ADecl)) {
159       // If we got a null return and something *was* parsed, ignore it.  This
160       // is due to a top-level semicolon, an action override, or a parse error
161       // skipping something.
162       if (ADecl && !Consumer->HandleTopLevelDecl(ADecl.get()))
163         return;
164     }
165   }
166 
167   // Process any TopLevelDecls generated by #pragma weak.
168   for (Decl *D : S.WeakTopLevelDecls())
169     Consumer->HandleTopLevelDecl(DeclGroupRef(D));
170 
171   Consumer->HandleTranslationUnit(S.getASTContext());
172 
173   // Finalize the template instantiation observer chain.
174   // FIXME: This (and init.) should be done in the Sema class, but because
175   // Sema does not have a reliable "Finalize" function (it has a
176   // destructor, but it is not guaranteed to be called ("-disable-free")).
177   // So, do the initialization above and do the finalization here:
178   finalize(S.TemplateInstCallbacks, S);
179 
180   std::swap(OldCollectStats, S.CollectStats);
181   if (PrintStats) {
182     llvm::errs() << "\nSTATISTICS:\n";
183     if (HaveLexer) P.getActions().PrintStats();
184     S.getASTContext().PrintStats();
185     Decl::PrintStats();
186     Stmt::PrintStats();
187     Consumer->PrintStats();
188   }
189 }
```

As above, there are two forms of `ParseAST` overloading.

Function param discription:

```c++
/// \param PrintStats Whether to print LLVM statistics related to parsing.
/// \param TUKind the kind of translation unit being parsed.
/// \param CompletionConsumer If given, an object to consume code completion results.
/// \param SkipFunctionBodies Whether to skip parsing of function bodies. This option can be used, for example, to speed up searches for declarations/definitions when indexing.
```

##### Note: Specially, Parse the main file known to the preprocessor, producing an abstract syntax tree.

Before analyzing the function body of `ParseAST`, you should understand what those class below do:

## Sema

​	This implements semantic analysis and AST building for C.

## Preprocessor

​	Engages in a tight little dance with the lexer to efficiently preprocess tokens.

​	Lexers know only about tokens within a single source file, and don't know anything about preprocessor-level issues like the \\#include stack, token expansion, etc.

## PreprocessorOptions

​	This class is used for passing the various options used in preprocessor initialization to InitializePreprocessor().

## ASTConsumer

​	This is an abstract interface that should be implemented by clients that read ASTs. This abstraction layer allows the client to be independent of the AST producer (e.g. parser vs AST dump file reader, etc).

## ASTContext

​	Holds long-lived AST nodes (such as types and decls) that can be referred to throughout the semantic analysis of a file.

## TranslationUnitKind

​	Describes the kind of translation unit being processed.

​	TU_Complete, the translation unit is a complete translation unit.

​	TU_Prefix, the translation unit is a prefix to a translation unit, and is not complete.

​	TU_Module, the translation unit is a module.

## CodeCompleteConsumer

​	Abstract interface for a consumer of code-completion information.

## Parser

​	This implements a parser for the C family of languages. After parsing units of the grammer, productions are invoked to handle whatever has been read.